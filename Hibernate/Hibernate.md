
# ORM
* Object Relational Mapping.
* Insert. Update, delete and select .in Object format only 

* className- Must be mapped with – tableName
* VariableName- Must be mapped with – columnName

* should be done by programmer using XML/Annotatios concept.
* Then ORM convert  Object-->ROW
* Here , ORM only generates SQL Query.


## Design Pattern:-

> This concept is used to improve applications performance by reducing code ,
time, and memory of on application.


### Hibernate has 3 Java Technologies
1. JDBC
2. JTA
3. JNDI And one Non-Java Technology “XML”.

####  **JDBC =Java Database Connectivity**
* It is used to perform database operations. Like insert, update, delete and select.

####  **JTA = Java Transaction API**
* It is used to either confirm (commit) changes or cancel (rollback) changes done at
database.

####  **JNDI= Java Naming Directory Interface**
* It is used to create connection-pool and execute SQL Statement faster.

## Hibernate Programming design:-

* JDBC works on primitive data even object is given, it converts Object Data to Primitive Data then
SQL Query return manually by programmer.

* Hibernate follows ORM Concept so, it converts object to Row even Row to Object. 
* SQL query also generated by ORM (Hibernate), But Programmer has to follow coding files in below order.

1. Configuration file
2. Model/Entity/POJO Class
3. Mapping code(XML/Annotation)

####  1. Configuration file
It is used to provide all details related to DB and Hibernate.
* a). it will store data in key = value format.
* b). file name should have extension ___.cfg.xml
* c). recommended name is:-`hibernate.cfg.xml`
* d). Few keys are:- driver_Class, url, dialect , show_sql

####  2. Model/Entity/POJO Class
Model Class + Rules given by hibernate:-
1. class must have package statement
2. Class must have public (no. of table =no. of classes)
3. variables must be private // (no. of column =no .of variables)
4. Default constructor with setters and getters (mutators).
5. Can override methods from Object , those are(3)
toString(), equals(), hashCode()non-final ,non-static,non-private.
6. Annotations:-JPA Annotations(Java Persistency API=JPA)

####  3. Mapping code(XML/Annotation)
####  4. Test Class [POJI-POJO]



# Hibernate Application Files:-
To write one application we should write 4 files, given as below:
1. Model class (Class)
2. Mapping Code (XML/ANNOTATION)
3. Configuration file (XML)
4. Test Class (class)


### Keys are given below (8 keys)

1) hibernate.connection.driver_class=oracle.jdbc.driver.OracleDriver
2) hibernate.connection.url=jdbc:oracle:thin@localhost:1521:xe
3) hibernate.connection.username=system
4) hibernate.connection.password=system
5) hibernate.dialect=org.hibernate.dialect.OracleDialect
6) hibernate.show_sql=true
7) hibernate.format_sql=true
8) hibernate.hbm2ddl.auto=update

 
## dialect
 Dialect is class it will be generate the SQL Query when programmer performsoperation, for every database dialect is different
##### EX:- 
* Oracle DB= OracleDialect
* MySQL DB= MySQLDialect
* Sybase DB= SybaseDialect
* H2 DB = H2Dialect
All dialect are defined in package org.hibernate.dialect

## show_sql:-
* show_sql:- it is a Boolean property default value is false. To see generated SQL on Console make value as true.
## format_sql:-
* format_sql:- it is a Boolean property default value is false. It will display sql clause by
clause (part by part)

```sql
Select
Eid ,nam
From
Emptab
Where
Eid=10
Value must be set to ‘true’
```


## hbm2ddl.auto:-
here **hbm**= hiberante mapping
 ddl=Data definition language(create /alter/drop in SQL) it has four possible value. Those are:-
* **Validate**:- in this case hibernate creates no tables programmer has to create or modify tables manually. It is only default value.
* **Create**:- hibernate creates always new tables, if table exist then it will be drop.
* **Update**:- it creates new table if table not exits else uses same tables.
* **Create-drop**:- this option is used for testing process not in development, it’s new table and performs operation at last table will be drop.


>  configuration file must follow naming rule given by hibernate for auto-detection.

Naming rule is: `hibernate.cfg.xml`


##  `hibernate.cfg.xml`


```xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEhibernate-configurationPUBLIC
"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
"http://hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	<session-factory>
		<propertyname="hibernate.connection.driver_class">oracle.jdbc.driver.OracleDriver</property>
		<propertyname="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe	</property>
		<propertyname="hibernate.connection.username">system</property>
		<propertyname="hibernate.connection.password">system</property>
		<propertyname="hiberante.dialect"> org.hibernate.dialect.OracleDialect</property>
		<propertyname="hibernate.show_sql">true	</property>
		<propertyname="hibernate.format_sql">true</property>
		<propertyname="hibernate.hbm2ddl.auto">update</property>
		<mappingclass="com.app.model.Product"/>
	</session-factory>
</hibernate-configuration>

```
## Execution flow
*  Create object to configuration (c)
*  Load .cfg.xml file into configuration using configure () method.
*  Build SessionFactory using cfg, which handles
      1. Loading driver class
      2. Creating connection
      3. Prepare statements
*  Open Session to perform on operation (either select or non-select)
* Begin Transaction(Tx) if non-select operation is to be performed.
* Now perform operation using session.
* Commit or rollback transaction if tx started.
* Close session at last.


## Coding Steps with Concept:-

1. Create empty configuration object using class “configuration” given by hibernate.
`Configuration cfg=new Configuration();`
2. Load hibernate.`cfg.xml` file into above object using method `configure()`
`cfg.configure();`
* if XML file name or location is different then code will be:
`cfg.configure(“abcd.cfg.xml”);`
`cfg.configure(“com/app/one.cfg.xml”);`
3. Create object to `SessionFactory `using `cfg`, which load driver class and creates connection and
statement type.
`SessionFactory sf=cfg.buildSessionFactory();`
4. To perform operations (Task) create one Session object using SF.
`Session ses=sf.openSession();`
5. Start one Transaction if operation type is non-select (insert, update and delete). If select
operation then Tx not required.
`Transaction tx=ses.beginTransaction();`
6. Perform operation using session
`................................
................................`
7. Either `commit `or `rollback `if Tx is started.
`tx.commit ()/tx.rollback()`;
8. Finally close Session
`ses.close()`;
