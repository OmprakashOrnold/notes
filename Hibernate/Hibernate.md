
# ORM
* Object Relational Mapping.
* Insert. Update, delete and select .in Object format only 

* className- Must be mapped with – tableName
* VariableName- Must be mapped with – columnName

* should be done by programmer using XML/Annotatios concept.
* Then ORM convert  Object-->ROW
* Here , ORM only generates SQL Query.


## Design Pattern:-

> This concept is used to improve applications performance by reducing code ,
time, and memory of on application.


### Hibernate has 3 Java Technologies
1. JDBC
2. JTA
3. JNDI And one Non-Java Technology “XML”.

####  **JDBC =Java Database Connectivity**
* It is used to perform database operations. Like insert, update, delete and select.

####  **JTA = Java Transaction API**
* It is used to either confirm (commit) changes or cancel (rollback) changes done at
database.

####  **JNDI= Java Naming Directory Interface**
* It is used to create connection-pool and execute SQL Statement faster.

## Hibernate Programming design:-

* JDBC works on primitive data even object is given, it converts Object Data to Primitive Data then
SQL Query return manually by programmer.

* Hibernate follows ORM Concept so, it converts object to Row even Row to Object. 
* SQL query also generated by ORM (Hibernate), But Programmer has to follow coding files in below order.

1. Configuration file
2. Model/Entity/POJO Class
3. Mapping code(XML/Annotation)

####  1. Configuration file
It is used to provide all details related to DB and Hibernate.
* a). it will store data in key = value format.
* b). file name should have extension ___.cfg.xml
* c). recommended name is:-`hibernate.cfg.xml`
* d). Few keys are:- driver_Class, url, dialect , show_sql

####  2. Model/Entity/POJO Class
Model Class + Rules given by hibernate:-
1. class must have package statement
2. Class must have public (no. of table =no. of classes)
3. variables must be private // (no. of column =no .of variables)
4. Default constructor with setters and getters (mutators).
5. Can override methods from Object , those are(3)
toString(), equals(), hashCode()non-final ,non-static,non-private.
6. Annotations:-JPA Annotations(Java Persistency API=JPA)

####  3. Mapping code(XML/Annotation)
####  4. Test Class [POJI-POJO]



# Hibernate Application Files:-
To write one application we should write 4 files, given as below:
1. Model class (Class)
2. Mapping Code (XML/ANNOTATION)
3. Configuration file (XML)
4. Test Class (class)


### Keys are given below (8 keys)

1) hibernate.connection.driver_class=oracle.jdbc.driver.OracleDriver
2) hibernate.connection.url=jdbc:oracle:thin@localhost:1521:xe
3) hibernate.connection.username=system
4) hibernate.connection.password=system
5) hibernate.dialect=org.hibernate.dialect.OracleDialect
6) hibernate.show_sql=true
7) hibernate.format_sql=true
8) hibernate.hbm2ddl.auto=update

 
## dialect
 Dialect is class it will be generate the SQL Query when programmer performsoperation, for every database dialect is different
##### EX:- 
* Oracle DB= OracleDialect
* MySQL DB= MySQLDialect
* Sybase DB= SybaseDialect
* H2 DB = H2Dialect
All dialect are defined in package org.hibernate.dialect

## show_sql:-
* show_sql:- it is a Boolean property default value is false. To see generated SQL on Console make value as true.
## format_sql:-
* format_sql:- it is a Boolean property default value is false. It will display sql clause by
clause (part by part)

```sql
Select
Eid ,nam
From
Emptab
Where
Eid=10
Value must be set to ‘true’
```


## hbm2ddl.auto:-
here **hbm**= hiberante mapping
 ddl=Data definition language(create /alter/drop in SQL) it has four possible value. Those are:-
* **Validate**:- in this case hibernate creates no tables programmer has to create or modify tables manually. It is only default value.
* **Create**:- hibernate creates always new tables, if table exist then it will be drop.
* **Update**:- it creates new table if table not exits else uses same tables.
* **Create-drop**:- this option is used for testing process not in development, it’s new table and performs operation at last table will be drop.


>  configuration file must follow naming rule given by hibernate for auto-detection.

Naming rule is: `hibernate.cfg.xml`


##  `hibernate.cfg.xml`


```xml
<?xmlversion="1.0"encoding="UTF-8"?>
<!DOCTYPEhibernate-configurationPUBLIC
"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
"http://hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
	<session-factory>
		<propertyname="hibernate.connection.driver_class">oracle.jdbc.driver.OracleDriver</property>
		<propertyname="hibernate.connection.url">jdbc:oracle:thin:@localhost:1521:xe	</property>
		<propertyname="hibernate.connection.username">system</property>
		<propertyname="hibernate.connection.password">system</property>
		<propertyname="hiberante.dialect"> org.hibernate.dialect.OracleDialect</property>
		<propertyname="hibernate.show_sql">true	</property>
		<propertyname="hibernate.format_sql">true</property>
		<propertyname="hibernate.hbm2ddl.auto">update</property>
		<mappingclass="com.app.model.Product"/>
	</session-factory>
</hibernate-configuration>

```
## Execution flow
*  Create object to configuration (c)
*  Load .cfg.xml file into configuration using configure () method.
*  Build SessionFactory using cfg, which handles
      1. Loading driver class
      2. Creating connection
      3. Prepare statements
*  Open Session to perform on operation (either select or non-select)
* Begin Transaction(Tx) if non-select operation is to be performed.
* Now perform operation using session.
* Commit or rollback transaction if tx started.
* Close session at last.


## Coding Steps with Concept:-

1. Create empty configuration object using class “`configuration`” given by hibernate.
`Configuration cfg=new Configuration();`
2. Load hibernate.`cfg.xml` file into above object using method `configure()`
`cfg.configure();`

###### Note 
if XML file name or location is different then code will be:
`cfg.configure(“abcd.cfg.xml”);`
`cfg.configure(“com/app/one.cfg.xml”);`
3. Create object to `SessionFactory `using `cfg`, which load driver class and creates connection and
statement type.
`SessionFactory sf=cfg.buildSessionFactory();`
4. To perform operations (Task) create one Session object using SF.
`Session ses=sf.openSession();`
5. Start one Transaction if operation type is non-select (insert, update and delete). If select
operation then Tx not required.
`Transaction tx=ses.beginTransaction();`
6. Perform operation using session
`................................
................................`
7. Either `commit `or `rollback `if Tx is started.
`tx.commit ()/tx.rollback()`;
8. Finally close Session
`ses.close()`;

## Session(I) in hibernate:-
* Session is an interface defined in Hibernate Framework.
* It is used to perform any operation in Hibernate.


```java
      Session ses= sf.openSession())
      try{
    
      }catch(Exception e) {
       e.prrintStackTrace();
      } finally{
      ses.close();
      }
```

### Given few examples as:
#### Non-select: 
* Save(obj):Serializable
* Update(obj):void
* Delete(obj):void
* saveOrUpdate(obj):void
#### Select:
* get(T.class,Id):T obj
* load(T.class,Id):T obj

Here T=Model class Name=type
> Above operations are one row --> one object (Single row) operations, it means at a time delete
one row , select one row, update one row ......etc.

## To perform multi-row operations Session(I) has provided
* Query
* Criteria APIs


> Transaction (tx) must be created using Session(I) in hibernate for non-select operations. It
is not applicable for select operations.


## Cache :- 
* It is a Temporary memory implemented by Hibernate framework(not in JDBC) 
* whichreduces network calls between Application and Database , that improves performance.


### Hibernate supports 2 type of Cache Management.

* Session Cache (First Level)
* Session Factory Cache(Second level)

(disabled by default),Which is handled by programmer.


# Session Operations:-

## Save(obj):- 
* this method is given from Session (I). 
* It is used to convert model class object to DB Table Row.
• Model class must have at least `@Entity`, `@Id` Annotations
• `@Table`, `@Column` are optional
* To avoid variable mapping column, use `@Transient`

> We can’t save new row into DB table with existed Primary key Id using Save() method
Hibernate will throw `ConstraintViolationException`

## Update(obj):void:-

> This method is used to update all columns data based on Primary key column.

* if Table has 50 columns, in that one is Primary key, then is we use ses.update(obj),
* it will update 49 columns based one 1 Primary key Column.
* If Given Primary key Id is not found then Hibernate throws (Unknown object State `StateObjectStateException`
* Row was updated or deleted by another transaction (or unsaved-value mapping....)


## ses.delete(obj):void:
> this method is used to delete one row from DB Table based on Primary key only
   a. This method will take input as “model class object having primary key value”
   b. First it will execute select query and loads data into cache(I-Level) if exist then delete
       query will be called, else does nothing.


## DATE and TIME in Hibernate:-

> Hibernate has provided enum to handle Date and time concept as column data named as
“TemporalType” given in Package:javax.persistence

## WORKING WITH CLOB AND BLOB TYPES IN HIBERNATE:-
Database support BLOB and CLOB to store large object in tables

## BLOB
* it is used to store large objects like audio, video,images,files,like documents PPT,excel
files etc....
* it also support pure text in hibernate code should be written as

```java
@Lob
Private byte[] img;
```


## CLOB
* Character Large Object used to store only text data. Code is

```java
@Lob
Private char[] mydata;
```

Example code


```java
@Lob
@Column(name="img")
private byte[] simg;
@Lob
@Column(name="doc")
private char[] stxt;
```


```java
import java.io.FileInputStream;
importjava.io.FileNotFoundException;
import org.hibernate.Session;
import org.hibernate.SessionFactory;
import org.hibernate.Transaction;
import org.hibernate.cfg.Configuration;
publicclass Test {
  publicstaticvoid main(String[] args) throws Exception {
    Configuration cfg = new Configuration();
    cfg.configure();
    SessionFactory sf = cfg.buildSessionFactory();
    Session ses = sf.openSession();
    Transaction tx = ses.beginTransaction();
    Student st = new Student();
    st.setStdId(1001);
    st.setStdName("Ram");
    st.setStdFee(22.2);
    FileInputStream fis = new FileInputStream("D:\\Ram.jpg");
    byte[] arr = newbyte[fis.available()];
    fis.read(arr);
    st.setSimg(arr);
    String str = "Welcome to Ramjatan ";
    char[] arr1 = str.toCharArray();
    st.setStxt(arr1);
    ses.save(st);
    tx.commit();
    ses.close();

  }
}
```
## Selecting/Fetching Data From DB Table using Hibernate:-

* Use get() or load() methods to fetch one row data based on Primary key. 
* It will return in Object format.

##  get() method

*  Hibernate search for Row based on Primary key
*  If found, Hibernate create object and set the data taken from Table row.
*  So we need to pass Class type input (Java.lang.Class) to get method.

Class (java.lang):- This is used to give information of a class like name, package, const,
variables, methods etc. to JVM /Framework/Containers.

* Syntax:- to create Class obj:-
    a. `Class c= Class.forName(“-------“);`
    b. `Class c=-------.class`

* This method is used to fetch one row to one object based on primary key.

Consider Emplyee as Example then code can be written as

```java
Employee e=ses.get(Class.forName(“com.app.Employee”),10);

```

```java
Employee e=ses.get(Employee.class,10);
```

* If Hibernate finds row based on Primary given then row will be converted to object else
null value is returned.

### code

1. Model class , mapping
2. Cfg file are same as before
3. Test class ://cfg,sf,ses


```java
Employee e ses.get(Employee.class,101);
System.out.println(e);
Ses.close();
```
## LOAD() method:- 
* This method also used to select one row data from DB table and converts tomodel class object.

```java
Syntax:
Load(Class<T> Clz,
Serializable id):T Obj
```
### code
1. Model class and mapping code
2. Cfg file are same as before
3. Test class:// cfg,sf,ses,

//save one object berfor this

```k
Employee e=ses.load(Employee.class,100);
Sysout(e);
Ses.close();
```

*) if row 101 is not existed then `ObjectNOtfoundException `is thrown by Hibernate.

## Get() execution flow:-

1. Call get method from hibernate method
2. On calling first time it will make network call by executing select query
3. In row exist it is converted to object and placed in Session Cache else object value is null.
4. Finally object return to Application.

## Load() Execution flow:-

1. Call load method in hibernate application
2. to application communication with cache
3. Cache create proxy object of model class and it will be set primary key value.
Proxy means dummy object created by hibernate.
4. This proxy is return back to application
5. On performing any operations over object (Print or any get method call) then it will
communicate to proxy for data.
6. Hibernate application makes Networks call by executing select query.
7. If row exist it is return back to Cache as object data.
8. Data return to applications.

## Get()vs Load()

| get()| load()|
| --- | --- |
| get hits DB on call| load hits  cache first|
| get return null if record not exits| load throws an exception if record not exist ObjectNotFound |
